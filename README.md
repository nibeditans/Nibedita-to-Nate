# Why this repository exists?

This repository backs a small GitHub Page titled **Why Nate?**.

The goal isn't to showcase a project or a framework. Instead, it captures a simple idea: how a single logical transformation can be expressed across different paradigms, and in this case, Python and SQL (MySQL & PostgreSQL).

## The underlying idea

At its core, the logic here is a **string transformation problem**:

- Identify anchor points (start, middle, end)
- Apply deterministic rules
- Combine the extracted pieces into a new representation

This is intentionally simple. The value isn't in the complexity of the problem, but in the **thinking process behind it**.

## Why Python and SQL?

The same transformation is written twice to highlight two mental models:

- **Python** expresses the logic imperatively, step by step.
    - View Code: **[Pyhton Version](https://github.com/nibeditans/Nibedita-to-Nate/blob/main/Nate.py)**
- **SQL** expresses the logic declaratively, describing what to extract rather than how to iterate.
    - View Code: **[SQL Version](https://github.com/nibeditans/Nibedita-to-Nate/blob/main/Nate.sql)**

This mirrors how real data work often looks:
- the problem stays the same
- the expression changes based on the tool

## Data thinking angle

Although this example uses a name instead of a dataset, the thinking is identical to everyday data tasks:

- feature extraction
- deterministic transformations
- expressing logic across different systems
- keeping solutions simple and explainable

This page is a small reflection of how I approach data problems in general.

## Live page

The rendered version of this content is available here: **[Nibedita-to-Nate](https://nibeditans.github.io/Nibedita-to-Nate/)**
